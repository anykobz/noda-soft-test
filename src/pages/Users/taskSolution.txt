// Мы ожидаем, что Вы исправите синтаксические ошибки, сделаете перехват возможных исключений и улучшите читаемость кода.
// А так же, напишите кастомный хук useThrottle и используете его там где это нужно.
// Желательно использование React.memo и React.useCallback там где это имеет смысл.
// Будет большим плюсом, если Вы сможете закэшировать получение случайного пользователя.
// Укажите правильные типы.
// По возможности пришлите Ваш вариант в https://codesandbox.io


Решение задачи:

1. Перенесла константу URL в функцию, где она непосредственно используется.
2. Переделала вид функциональных компонентов на стрелочные функции.

3. Для улучшения пользовательского опыта, добавила обработку загрузки и ошибок с помощью стейтов:
   - Добавила отлавливание ошибок внутри функции receiveRandomUser.
   - Чтобы отлавливать ошибки запросов, использую условие if (!response.ok) {...} с ранним ретёрном.
   - Для дополнительной защиты от сетевых ошибок добавила обёртку try/catch/finally.

4. Ошибки типов:
   - В стейте item не было никакой причины использовать тип Record<number, User>. Компонент UserInfo ожидает тип User и setItem также передаёт объект типа User.
   - Поменяла в стейте тип на User и добавила, что значение также может быть null, поскольку это начальное значение.
   - Добавила тип Address и подставила его вместо any в интерфейсе User.

5. Добавила обработку null в компоненту UserInfo, а также опциональную цепочку чтобы избежать ошибок при user === null.

6. Кеширование пользователя:
   - Внутри компонента с использованием хука useRef, чтобы сохранять кеш в течение жизни компонента.
   - Для этой цели обычно использую React TanstackQuery, но для текущей задачи это оправдано.

7. Реализовала кастомный хук useThrottle, положила его в общедоступную папку hooks:
   - Использование возможно в любом компоненте приложения.
   - В App прикрутила его к функции, срабатывающей при нажатии кнопки, и поставила таймер 0,5 сек.
   - Если пользователь пытается получить данные раньше - выводится уведомление и оставшееся время до следующего запроса.

8. В useThrottle реализовала хук useCallback для того, чтобы функция пересоздавалась только при изменении одной из зависимостей: [func, timer, delay]. Если их не использовать - могут быть вызваны лишние рендеры дочерних компонентов и эффектов от неё зависящих.

9. Компоненты не нуждаются в оборачивании хуком useMemo, так как они не содержат сложных вычислений и визуально нет никаких лишних перерисовок компонентов.

10. Добавила каталог pages. Разбила страницу App на компоненты.